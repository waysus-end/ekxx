<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Вопросы-Ответы</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #000;
            color: #fff;
            line-height: 1.4;
            padding: 10px;
            max-width: 448px;
            margin: 0 auto;
            overflow-x: hidden;
        }
        
        .container {
            width: 100%;
            padding: 5px;
        }
        
        .questions-list {
            margin-top: 5px;
        }
        
        .question-item {
            background-color: #1c1c1e;
            border-radius: 12px;
            margin-bottom: 10px;
            overflow: hidden;
            border-left: 4px solid #0a84ff;
        }
        
        .question-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        
        .question-title {
            font-size: 16px;
            font-weight: 500;
            flex: 1;
        }
        
        .toggle-icon {
            color: #0a84ff;
            font-size: 18px;
            transition: transform 0.3s ease;
            flex-shrink: 0;
            margin-left: 10px;
        }
        
        .answer-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background-color: #2c2c2e;
        }
        
        .answer-text {
            padding: 15px;
            font-size: 15px;
            color: #ddd;
            border-top: 1px solid #333;
            white-space: normal;
            overflow-wrap: break-word;
        }
        
        .question-item.active .toggle-icon {
            transform: rotate(180deg);
        }
        
        .question-item.active .answer-content {
            max-height: 2000px; /* Увеличил для полного отображения ответов */
        }
        
        .controls {
            display: flex;
            justify-content: center;
            margin-top: 15px;
        }
        
        .control-btn {
            background-color: #333;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        }
        
        /* Адаптация для очень маленьких экранов */
        @media (max-width: 400px) {
            body {
                padding: 8px;
            }
            
            .question-header {
                padding: 12px;
            }
            
            .question-title {
                font-size: 15px;
            }
            
            .answer-text {
                padding: 12px;
                font-size: 14px;
            }
            
            .control-btn {
                padding: 8px 16px;
                font-size: 13px;
            }
        }
        
        /* Темная тема по умолчанию */
        @media (prefers-color-scheme: light) {
            body {
                background-color: #f2f2f7;
                color: #000;
            }
            
            .question-item {
                background-color: #fff;
                border-left-color: #007aff;
            }
            
            .answer-content {
                background-color: #f2f2f7;
                border-top-color: #c7c7cc;
            }
            
            .answer-text {
                color: #333;
            }
            
            .control-btn {
                background-color: #e5e5ea;
                color: #000;
            }
        }
    </style>
</head>
<body>
    <h1>Экзаменационные вопросы</h1>
    <div class="container">
        <div class="questions-list" id="questions-container">
            <!-- Вопросы будут добавлены через JavaScript -->
        </div>
        
        <div class="controls">
            <button class="control-btn" id="collapse-all">Свернуть все</button>
        </div>
    </div>

    <script>
        // Данные вопросов и ответов
        const questionsData = [
            {
                id: 1,
                question: "1. Основные принципы организации процесса тестирования?",
                answer: "1. Принцип раннего тестирования (Early Testing): Тестирование начинается на ранних стадиях ЖЦ (анализ требований, дизайн) для снижения стоимости исправления дефектов. Основной инструмент — статическое тестирование (ревью, инспекции). <BR> 2. Принцип независимости (Independence): Эффективность тестирования повышается при вовлечении независимых специалистов (от разработчиков). Уровни: от автора (низкая) до внешней команды (высокая). <BR> 3. Принцип приоритета (Priority-based Testing): Ресурсы концентрируются на тестировании наиболее критичного функционала (на основе оценки рисков, частоты использования, важности для бизнеса). Применяется при планировании тестов и управлении дефектами. <BR> 4. Принцип 'отсутствия ошибок — fallacy' (Absence-of-errors fallacy): Система без дефектов, но не соответствующая требованиям пользователя, бесполезна. Цель — проверка соответствия ожиданиям, а не только поиск багов. <BR> 5. Принцип кластеризации дефектов (Defect Clustering): Основная часть дефектов обнаруживается в ограниченном числе модулей (правило Парето 80/20). Позволяет оптимизировать усилия. <BR> 6. Парадокс пестицида (Pesticide Paradox): Повторение одних и тех же тестов снижает их эффективность. Необходимо регулярно ревизовать и обновлять тестовые сценарии. <BR> 7. Контекстная зависимость (Context Dependence): Подход к тестированию зависит от типа системы (веб, мобильное приложение), бизнес-области, требований, сроков и бюджета. <BR> 8. Тестирование показывает наличие дефектов (Testing Shows Presence of Defects): Тестирование может доказать наличие дефектов, но не их отсутствие. Цель — снизить количество необнаруженных дефектов до приемлемого уровня. <BR> Практический итог для экзамена: Организация тестирования строится на этих принципах для эффективного использования ресурсов, минимизации рисков и обеспечения соответствия ИС заданным требованиям."
            },
            {
                id: 2,
                question: "2. Цели и область тестирования",
                answer: "<strong> Цели: </strong> Основная — выявление дефектов для обеспечения качества и соответствия требованиям. Дополнительные: оценка готовности к выпуску, снижение рисков, предоставление информации о качестве заказчику. <BR> <strong> Область тестирования: </strong> Определяет, что будет тестироваться (функции, компоненты) и как (виды тестов). Ограничивается требованиями, рисками, ресурсами и целями проекта. Четко описывается в тест-плане."
            },
            {
                id: 3,
                question: "3. Коммуникация и взаимодействие в процессе тестирования",
                answer: "Коммуникация и взаимодействие в процессе тестирования информационных систем включают обмен информацией между тестировщиками, разработчиками, аналитиками, заказчиками и заинтересованными сторонами для обеспечения качества ПО.<BR>Тестировщики используют отчеты о дефектах (bug reports), статус-репорты, стендапы, встречи для обсуждения результатов тестов, рисков и плана исправлений.<BR>Эффективная коммуникация подразумевает четкие требования, использование инструментов (Jira, TestRail), устные/письменные формы с фактами и метриками для минимизации недоразумений."
            },
            {
                id: 4,
                question: "4. Методология тестирования",
                answer: "Методология тестирования информационных систем - это системный подход к планированию, организации и проведению тестов для обеспечения качества ПО, включающий выбор методов, этапов и инструментов в соответствии с жизненным циклом разработки.<BR>Основные методологии: классическая (водопадная) с последовательными этапами (модульное, интеграционное, системное, приемочное тестирование); Agile (гибкая) с итеративным тестированием в спринтах; TDD (тест-дривен разработка) и BDD (поведенчески-ориентированное).<BR>Критерии выбора: тип ПО, риски, ресурсы; принципы - полнота, воспроизводимость, независимость"
            },
            {
                id: 5,
                question: "5. Тестовые среды",
                answer: "Тестовые среды - это конфигурации аппаратного и программного обеспечения (серверы, ОС, БД, сети, тестовые данные), имитирующие реальную среду для проведения тестов без влияния на продакшн.<BR>Виды: <strong>разработческая (Dev)</strong> для unit-тестов; <strong>тестовая (Test) </strong> для функционального/регрессионного тестирования; <strong>интеграционная (Integration)</strong> для проверки взаимодействий модулей; <strong>приемочная (Stage)</strong> для UAT; <strong>производственная (Prod)</strong> только для финальной проверки.<BR>Настройка включает документацию, инструменты (Selenium, Docker), обеспечение воспроизводимости и изоляции"
            },
            {
                id: 6,
                question: "6. Современные технологии тестирования. Виды тестирования ПО",
                answer: "Современные технологии тестирования ПО включают автоматизацию (Selenium для веб, Appium для мобильных), ИИ для умных тестов, Jenkins для CI/CD и облачные сервисы вроде BrowserStack.<BR>Виды тестирования: по уровням - модульное (unit), интеграционное, системное, приемочное; по методам - черный ящик (функциональное), белый ящик (код), серый; нефункциональное - нагрузочное (JMeter), безопасность, usability.<BR>Другие: регрессионное (повтор после изменений), smoke (быстрая проверка), exploratory (исследовательское без скриптов)."
            },
            {
                id: 7,
                question: "7. Виды тестирования ПО. Классификация в зависимости от ис-полнителей, целей тестирования",
                answer: "Виды тестирования ПО классифицируют по исполнителям и целям: по исполнителям - модульное (разработчики), интеграционное (тестировщики/разработчики), системное (тестировщики), приемочное (заказчики/пользователи).<BR>По целям - функциональное (проверка функций: unit, интеграция, система, UAT), нефункциональное (производительность, безопасность, usability, нагрузка), регрессионное (после изменений), smoke (основные функции).<BR>Эта классификация помогает выбрать тесты для разных этапов и ролей в проекте"
            },
            {
                id: 8,
                question: "8. Основы тестирования. Классы критериев тестирования",
                answer: "Основы тестирования - это процесс проверки ПО на наличие дефектов и соответствие требованиям для обеспечения качества.<BR>Классы критериев тестирования: функциональные (соответствие функциям), нефункциональные (производительность, надежность, безопасность), структурные (покрытие кода), экспертные (оценка рисков, usability).<BR>Критерии помогают определить 'стоп' тестирования: покрытие 80-90%, отсутствие критических багов, по времени/ресурсам"
            },
            {
                id: 9,
                question: "9. Фазы тестирования",
                answer: "Фазы тестирования (STLC) - это последовательные этапы жизненного цикла: анализ требований (изучение ТЗ), планирование (стратегия, ресурсы), разработка тест-кейсов (сценарии проверок), настройка тестовой среды (установка ПО/серверов), выполнение тестов (запуск, фиксация багов), завершение (отчеты, анализ результатов).<BR>Каждый этап имеет входные/выходные документы и критерии перехода к следующему для контроля качества ПО.<BR>Цель - системный подход к выявлению дефектов на ранних стадиях"
            },
            {
                id: 10,
                question: "10. Этапы тестирования",
                answer: "Этапы тестирования ПО (STLC): 1) Анализ требований (изучение ТЗ, выявление рисков); 2) Планирование (стратегия, ресурсы, сроки); 3) Разработка тест-кейсов (сценарии проверок); 4) Настройка тестовой среды (ПО, серверы, данные); 5) Выполнение тестов (запуск, фиксация багов); 6) Завершение (отчеты, анализ, архив).<BR>Каждый этап имеет вход/выход документы и критерии перехода для контроля качества.<BR>Цель - системная проверка от начала до релиза"
            },
            {
                id: 11,
                question: "11. Типы тестов в тестовом плане ",
                answer: "Типы тестов в тестовом плане - это перечень проверок, которые будут проводиться: функциональные проверяют, работает ли ПО по требованиям ТЗ; нефункциональные - скорость, безопасность и удобство; модульные (unit) тестируют отдельные части кода; интеграционные - взаимодействие модулей; системные - всю систему целиком; приемочные - соответствие ожиданиям заказчика; регрессионные - повторяют тесты после изменений; smoke - быстрая проверка базовых функций.<BR>Тестовый план описывает, сколько тестов каждого типа, кто их делает, в какой последовательности и с каким приоритетом для покрытия всех рисков.<BR>Пример распределения: 70% на функциональные, 20% на нагрузку, 10% на безопасность."
            },
            {
                id: 12,
                question: "12. Типы тестирования по способу выбора входных значений",
                answer: "Типы тестирования по способу выбора входных значений: черный ящик (выбор по спецификации без знания кода - эквивалентное разбиение, граничные значения, попарное), белый ящик (по структуре кода - покрытие путей, условий), серый ящик (комбинация - частичный доступ к коду).<BR>Эквивалентное разбиение группирует похожие данные, граничные проверяют края диапазонов, попарное - комбинации параметров.<BR>Выбор зависит от уровня знаний о ПО и целей покрытия"
            },
            {
                id: 13,
                question: "13. Test Driven Development (TDD) - Разработка ПО на основе те-стов",
                answer: "TDD (Test Driven Development (Разработка на основе тестирования))  - разработка ПО на основе тестов: сначала пишется тест (Red - тест падает), затем минимальный код для прохождения теста (Green), потом рефакторинг (Refactor) с сохранением прохождения всех тестов.<BR>Цикл Red-Green-Refactor повторяется для каждой функции, обеспечивает 100% покрытие тестами, чистый код и быстрое выявление ошибок.<BR>Преимущества: меньше багов, проще рефакторинг, лучше дизайн"
            },
            {
                id: 14,
                question: "14. Документированность процесса тестирования",
                answer: "Документированность процесса тестирования - это создание и ведение документов (тест-план, тест-кейсы, чек-листы, баг-репорты, отчеты) для описания стратегии, выполнения и результатов тестов по стандарту IEEE 829.<BR>Обеспечивает воспроизводимость, контроль качества, передачу знаний команде и доказательство выполнения работ заказчику.<BR>Основные документы: тест-план (объем, риски), тест-кейсы (шаги, ожидаемый результат), отчеты (покрытие, дефекты)."
            },
            {
                id: 15,
                question: "15. Требования (срецификации). Атрибуты требований",
                answer: "Требования (спецификации) - это описания того, что должно делать ПО, зафиксированные в документе ТЗ с четкими функциями и ограничениями.<BR>Атрибуты требований: идентификатор (уникальный номер), описание (что именно), приоритет (высокий/средний/низкий), источник (от кого), статус (утверждено/изменено), версировка, критерии приемки (как проверить).<BR>Хорошие требования: полные, однозначные, проверяемые, необходимые, трассируемые для правильной разработки и тестирования."
            },
            {
                id: 16,
                question: "16. Дефект (bug) — отклонение фактического результата от ожи-даемого",
                answer: "Дефект (bug) — это отклонение фактического результата работы ПО от ожидаемого по требованиям, вызванное ошибкой в коде или спецификации.<BR>При выполнении теста дефект проявляется как сбой (failure), фиксируется в баг-репорте с шагами воспроизведения, скриншотами и приоритетом (критический/высокий/низкий).<BR>Управление: New → Assigned → Fixed → Verified → Closed для контроля качества."
            },
            {
                id: 17,
                question: "17. Инструменты для управления дефектами",
                answer: "Инструменты для управления дефектами: Jira (создание багов, назначение, статусы, дашборды), Bugzilla (бесплатная, трекинг lifecycle), TestRail (интеграция с тестами), Trello (визуальные доски), YouTrack (гибкие workflows).<BR>Они позволяют регистрировать дефекты с шагами, скриншотами, приоритетами, отслеживать статус (New-Fixed-Closed) и генерировать отчеты.<BR>Выбор зависит от команды: Jira для больших проектов, Trello для малого."
            },
            {
                id: 18,
                question: "18. Жизненный цикл дефекта (бага)",
                answer: "Жизненный цикл дефекта (бага): New (новый, создан тестировщиком) → Assigned (назначен разработчику) → In Progress (в работе) → Fixed (исправлен) → Retest (повторное тестирование) → Verified (проверен) → Closed (закрыт) или Reopened (повторно открыт при неудаче).<BR>Возможные статусы: Rejected (отклонен), Deferred (отложен) для неактуальных багов.<BR>Цель - отслеживание от выявления до устранения для контроля качества."
            },
            {
                id: 19,
                question: "19. Приведите перечень 'Поля отчёта о дефекте'",
                answer: "Поля отчёта о дефекте: Идентификатор (уникальный номер), Заголовок (краткое описание), Описание (шаги воспроизведения), Фактический результат, Ожидаемый результат, Среда (ОС, браузер, версия ПО), Приоритет/Серьёзность (критический/высокий), Вложения (скриншоты, видео), Статус (New/Assigned/Fixed), Автор и Назначенный.<BR>Эти поля стандартизированы по IEEE 829 для точного понимания и исправления бага командой.<BR>Пример заголовка: '[Логин] - Кнопка неактивна после 3 неверных паролей'."
            },
            {
                id: 20,
                question: "20. Методология тестирования сложных систем",
                answer: "Методология тестирования сложных систем (большое ПО, распределенные системы) использует модель V-Model (каждый этап разработки имеет соответствующий тест), Agile/Scrum с итеративным тестированием и Risk-Based Testing (приоритет по рискам).<BR>Этапы: модульное → интеграционное → системное → приемочное; инструменты - контейнеризация (Docker), CI/CD (Jenkins), мониторинг (ELK-stack).<BR>Особенности: параллельное тестирование, автоматизация нагрузки (JMeter), покрытие 90%+ кода."
            },
            {
                id: 21,
                question: "21. Особенности тестирования web-приложений",
                answer: "Особенности тестирования web-приложений: кроссбраузерность (Chrome, Firefox, Safari, Edge), адаптивность (мобильные/десктоп), совместимость (ОС Windows/Linux/Mac, разрешения экранов).<BR>Проверки: функционал форм/API (GET/POST), производительность (загрузка страниц), безопасность (SQL-инъекции, XSS), cookies/sessions; инструменты Selenium, Postman, JMeter.<BR>Учет сетевых задержек, HTTPS и мобильной ориентации для имитации реального использования."
            },
            {
                id: 22,
                question: "22. Тестирование пользовательского интерфейса",
                answer: "Тестирование пользовательского интерфейса (UI) проверяет внешний вид, удобство и работу элементов (кнопки, формы, меню) на разных устройствах и браузерах.<BR>Методы: функциональное (клики, ввод данных), визуальное (цвета, шрифты, адаптивность), usability (удобство для пользователя), кроссбраузерное (Chrome/Firefox/Safari); инструменты Selenium, TestCafe, Cypress.<BR>Цель - обеспечить интуитивность и отсутствие визуальных багов."
            },
            {
                id: 23,
                question: "23. Ручное тестирование",
                answer: "Ручное тестирование - это проверка ПО тестировщиком вручную без скриптов: выполнение тест-кейсов, ввод данных, клики, анализ поведения интерфейса.<BR>Преимущества: выявляет usability-проблемы, exploratory-тесты (исследовательские), подходит для новых функций; минусы - долго, зависит от человека.<BR>Используется для UI/UX, smoke, приемочных тестов; дополняет автоматизацию."
            },
            {
                id: 24,
                question: "24. Взаимосвязь видов и этапов тестирования",
                answer: "Взаимосвязь видов и этапов тестирования: модульное (unit) - ранний этап разработки; интеграционное - сборка модулей; системное - полная система; приемочное (UAT) - перед релизом заказчику.<BR>Регрессионное и smoke проходят на всех этапах после изменений; функциональное - системное/приемочное; нефункциональное (нагрузка) - системное.<BR>V-модель связывает каждый этап разработки с соответствующим тестированием для полного покрытия."
            },
            {
                id: 25,
                question: "25. Функциональное  тестирование",
                answer: "Функциональное тестирование проверяет, работает ли ПО по требованиям ТЗ: ввод данных → ожидаемый результат (black box, без знания кода).<BR>Виды: модульное (unit - разработчики), интеграционное (взаимодействие модулей), системное (вся система), приемочное (UAT - заказчик); методы - положительное (нормальные сценарии), негативное (ошибки ввода).<BR>Инструменты: тест-кейсы в TestRail, Postman для API."
            },
            {
                id: 26,
                question: "26. Структурное тестирование",
                answer: "Структурное тестирование (белый ящик) - проверка внутренней структуры кода: анализ логики, путей выполнения, условий для полного покрытия (операторы, ветви, пути).<BR>Методы: покрытие строк (каждый оператор), покрытие ветвей (true/false условия), покрытие путей (все варианты выполнения); используется разработчиками на unit/интеграционном уровнях.<BR>Инструменты: JaCoCo, SonarQube, Istanbul для измерения покрытия"
            },
            {
                id: 27,
                question: "27. Тестирование покрытия программного кода",
                answer: "Тестирование покрытия программного кода измеряет процент кода, выполненного тестами: строчное (line - каждая строка), ветвление (branch - if/else true/false), условия (condition - булевы выражения), пути (path - все варианты выполнения).<BR>Цель - 70-90% покрытия для снижения рисков; инструменты JaCoCo (Java), Coverage.py (Python), SonarQube.<BR>Проводится в структурном тестировании (белый ящик) разработчиками."
            },
            {
                id: 28,
                question: "28. Тестирование скорости загрузки системы",
                answer: "Тестирование скорости загрузки системы (performance/load testing) проверяет время отклика, загрузки страниц/компонентов под нагрузкой (1-1000+ пользователей).<BR>Методы: базовая нагрузка (JMeter), стресс-тесты (максимум до сбоя), endurance (длительная работа); метрики - LCP <2.5с, FCP <1.8с, TTFB <200мс.<BR>Инструменты: Google PageSpeed, JMeter, WebPageTest для выявления узких мест"
            },
            {
                id: 29,
                question: "29. Тестирование функциональных требований. Комплексное те-стирование",
                answer: "Тестирование функциональных требований проверяет соответствие ПО описанным в ТЗ функциям (black box): ввод → ожидаемый результат по спецификации.<BR>Комплексное тестирование (system/integration) - полная проверка сквозных сценариев взаимодействия модулей от начала до конца (end-to-end).<BR>Методы: тест-кейсы по требованиям, положительное/негативное тестирование, граничные значения"
            },
            {
                id: 30,
                question: "30. Модульное тестирование и интеграционное тестирование",
                answer: "Модульное тестирование (unit) - проверка отдельных функций/методов в изоляции с заглушками (mocks), белый ящик, разработчики, инструменты JUnit/Pytest.<BR>Интеграционное - тестирование взаимодействия модулей/компонентов (API, БД), выявление ошибок интерфейсов, top-down/bottom-up подходы.<BR>Модульное раньше, интеграционное после для проверки связей."
            },
            {
                id: 31,
                question: "31. Тестирование на основе потока управления и потока данных",
                answer: "Тестирование на основе потока управления (Control Flow) - анализ графа путей выполнения кода (белый ящик): покрытие операторов, ветвей (if/else), условий, путей для проверки логики.<BR>Тестирование потока данных (Data Flow) - отслеживание переменных: определение (def), использование (use), убийство (kill) для выявления неинициализированных данных или утечек.<BR>Методы структурные, цель - максимальное покрытие кода"
            },
            {
                id: 32,
                question: "32. Методы проектирования тестовых путей для достижения за-данной степени тестированности в структурном тестировании. ",
                answer: "Методы проектирования тестовых путей в структурном тестировании: статические (эвристические - простые пути, адаптивные - по сложности), динамические (символьное выполнение, покрытие ветвей/условий), методы реализуемых путей (построение графа, выбор путей по критериям покрытия строк/ветвей/путей).<BR>Цель - достижение заданной степени тестированности (80-100% покрытия) через анализ управляющего графа программы.<BR>Применяется в белом ящике для unit/интеграционного тестирования."
            },
            {
                id: 33,
                question: "33. Интеграционное тестирование",
                answer: "Интеграционное тестирование проверяет взаимодействие модулей/компонентов после модульного тестирования: выявляет ошибки интерфейсов, передачи данных, API.<BR>Подходы: Big Bang (все сразу), Top-Down (сверху вниз с заглушками), Bottom-Up (снизу вверх с драйверами), Sandwich (комбинированный).<BR>Цель - обеспечить правильную работу связей перед системным тестированием."
            },
            {
                id: 34,
                question: "34. Особенности интеграционного тестирования для процедурного программирования",
                answer: "Особенности интеграционного тестирования для процедурного программирования: проверка вызовов процедур/функций через граф модели программы (ГМП), тестирование потоков управления и данных между модулями с заглушками (stubs/driv ers).<BR>Подходы: bottom-up (снизу вверх с драйверами), top-down (сверху вниз со стубами), Big Bang; фокус на интерфейсах, параметрах передачи, глобальных переменных.<BR>Цель - выявление ошибок в связях процедур без знания внутренней логики"
            },
            {
                id: 35,
                question: "35. Интеграционное тестирование и его особенности для объектно-ориентированного программирования",
                answer: "Особенности интеграционного тестирования для ООП: проверка полиморфизма (переопределение методов), наследования (P-пути между классами), инкапсуляции (MM-пути для доступа к полям), взаимодействий объектов через граф классов с заглушками для абстрактных классов.<BR>Подходы: thread-based (по потокам объектов), call-graph (по вызовам методов); фокус на интерфейсах, исключениях, фабриках; сложность выше из-за динамической привязки.<BR>Цель - выявление ошибок в связях объектов, не проверяемых в модульном тестировании."
            },
            {
                id: 36,
                question: "36. Автоматизация тестирования",
                answer: "Автоматизация тестирования - использование скриптов и инструментов (Selenium, Appium, JUnit) для автоматического запуска тест-кейсов вместо ручного выполнения.<BR>Преимущества: быстрое регрессионное тестирование, CI/CD интеграция (Jenkins), повторяемость; подходит для unit, API, UI; минусы - дорогое создание, не для usability.<BR>Этапы: выбор инструментов, написание скриптов, запуск в пайплайне для стабильного качества ПО"
            },
            {
                id: 37,
                question: "37. Автоматизировать тестирование web-приложений с использо-ванием Selenium IDE",
                answer: "Автоматизация web-приложений с Selenium IDE: установить расширение в Firefox/Chrome, записать тест (Record) - клики, ввод текста, навигация; воспроизвести (Play), редактировать команды (assert, waitForElement).<BR>Преимущества: без кода, быстро для smoke/регрессии; экспорт в Selenium WebDriver (Python/Java); минусы - хрупкие тесты при изменениях UI.<BR>Используется для простых сценариев, дополняет ручное тестирование."
            },
            {
                id: 38,
                question: "38. Юзабилити-тестирование",
                answer: "Юзабилити-тестирование проверяет удобство интерфейса для пользователей: время выполнения задач, частота ошибок, субъективное удовлетворение (опросы).<BR>Методы: модерируемое (наблюдение за 5-8 пользователями), немодерируемое (опросы UserTesting), A/B-тесты, eye-tracking, card sorting.<BR>Цель - выявить проблемы навигации и UX до релиза."
            },
            {
                id: 39,
                question: "39. Метрики тестирования программного обеспечения",
                answer: "Метрики тестирования ПО: дефекты на 1000 строк кода (KLOC), покрытие тестами (requirements/code coverage 70-90%), passed/failed тесты (pass rate >95%), Defect Removal Efficiency (DRE = дефекты в тестах / все дефекты *100%), время на тест-кейс, тест-кейсы на требование.<BR>Процессные: продуктивность подготовки тест-кейсов (кол-во/человеко-часы); продуктовые: плотность дефектов, escape defects (после релиза).<BR>Цель - оценка качества, прогресса, эффективности команды."
            },
            {
                id: 40,
                question: "40. Тестирование ПО. Требования к разрабатываемому ПО",
                answer: "Тестирование ПО проводится на основе требований к разрабатываемому ПО, которые делятся на функциональные (что система должна делать: функции, сценарии) и нефункциональные (как: производительность, безопасность, usability).<BR>Требования документируются в ТЗ/SRS с атрибутами (ID, приоритет, критерии приемки) для создания тест-кейсов и проверки соответствия.<BR>Хорошие требования полные, однозначные, проверяемые для эффективного тестирования."
            },
            {
                id: 41,
                question: "41. Тестирование ПО. Качество разрабатываемого продукта",
                answer: "Тестирование ПО проверяет качество продукта по простым критериям: работает ли как надо (функции), не падает ли (надежность), удобно ли пользоваться, быстро ли загружается, легко ли править и переносить на другие системы.<BR>Показатели качества: меньше 1 бага на 1000 строк кода, тесты покрывают больше 80% кода, система работает стабильно долгое время, мало багов доходит до пользователей.<BR>Цель - выпустить программу без ошибок, которая нравится пользователям."
            },
            {
                id: 42,
                question: "42. Тестирование ПО. Возможности и эффективность команды QA",
                answer: "Команда QA (группа специалистов по тестированию ПО, которая проверяет программу на ошибки, удобство и качество на всех этапах разработки) тестирует ПО на всех этапах: анализирует требования, пишет планы и тест-кейсы, находит баги, проверяет исправления, дает отчеты о готовности продукта.<BR>Возможности: ручное/автоматизированное тестирование, нагрузка, безопасность, usability; эффективность измеряют метриками - % пройденных тестов (>95%), баги на 1000 строк (<1), покрытие тестами (>80%).<BR>Хорошая команда ускоряет релиз, снижает затраты на исправления, повышает качество."
            },
            {
                id: 43,
                question: "43. Тестирование ПО. Качество работы команды тестирования",
                answer: "Качество работы команды тестирования оценивают простыми показателями: % пройденных тестов (>95%), баги на 1000 строк кода (<1), покрытие тестами (>80%), время нахождения бага (меньше - лучше).<BR>Другие метрики: сколько тест-кейсов пишут в день, % автоматизации (>50%), сколько критических багов нашли до релиза (>90%).<BR>Хорошая команда быстро находит ошибки, покрывает много кода тестами и помогает выпускать качественное ПО."
            },
            {
                id: 44,
                question: "44. Тестирование ПО. Обратная связь и удовлетворенность поль-зователей",
                answer: "Тестирование ПО собирает обратную связь от пользователей через usability-тесты, опросы, A/B-тесты, анализ багов и метрики (NPS >7, время на задачу <2мин, % отказов <5%).<BR>Удовлетворенность проверяют: удобно ли пользоваться, понятны ли кнопки, быстро ли работает; хорошие отзывы - ПО успешно.<BR>Обратная связь помогает улучшать продукт до и после релиза."
            },
            {
                id: 45,
                question: "45. Процесс и фазы индустриального тестирования ",
                answer: "Процесс индустриального тестирования ПО включает фазы: планирование (цели, ресурсы), разработка тестов (кейсы), настройка среды, выполнение тестов (модульное→интеграционное→системное→приемочное), анализ результатов, отчеты.<BR>Тестовый цикл: прогон тестов, фиксация багов, исправление, ретест до критериев качества (покрытие >80%, критических багов =0).<BR>Особенность - автоматизация, стандарты (IEEE 829), метрики для промышленного производства надежного ПО"
            },
            {
                id: 46,
                question: "46. Тестовый цикл индустриального тестирования",
                answer: "Тестовый цикл индустриального тестирования: 1) планирование (план, ресурсы), 2) разработка тестов (кейсы), 3) настройка среды, 4) выполнение (прогон тестов, баги), 5) анализ (ретро, ретест), 6) отчет (готовность).<BR>Повторяется до критериев: 95% тестов пройдено, нет критических багов.<BR>Автоматизировано для больших проектов."
            },
            {
                id: 47,
                question: "47. Индустриальное  тестирование. Планирование тестирования. Тестовый план",
                answer: "Индустриальное тестирование планируют через тестовый план (по IEEE 829): цели (что тестировать), объем (какие функции), ресурсы (люди, инструменты), график (сроки циклов), риски, критерии выхода (95% тестов пройдено).<BR>План распределяет усилия между unit, интеграцией, системным тестированием для надежного ПО.<BR>Создается на старте проекта, утверждается с разработчиками"
            },
            {
                id: 48,
                question: "48. Тестовая документация. Чек-лист",
                answer: "Чек-лист - это простой список пунктов для проверки без подробных шагов: 'кнопка работает?'', 'форма сохраняет?', 'ошибка показывает текст?'.<BR>Используется для быстрого smoke-тестирования, exploratory, когда нет времени на тест-кейсы; легче писать и выполнять.<BR>Пример: ✓ Логин с верными данными, ✓ Логин с неверным паролем, ✗ Забыли пароль."
            },
            {
                id: 49,
                question: "49. Тестовая документация. Тест кейс",
                answer: "Тест-кейс - подробная инструкция для проверки: ID (номер), название (что проверяем), предусловия (что нужно перед тестом), шаги (1. открыть страницу, 2. ввести логин), ожидаемый результат (показать профиль).<BR>Используется для точного повторения тестов другими людьми; пишется по требованиям ТЗ.<BR>Пример: TC_001 'Успешный логин' - шаг 1: ввести верный логин/пароль, результат: вход в систему."
            },
            {
                id: 50,
                question: "50. Цель написания тест-кейсов",
                answer: "Цель тест-кейсов - дать четкие инструкции для проверки функций ПО: шаги, данные, ожидаемый результат для точного тестирования, повторения другими людьми и доказательства качества.<BR>Они стандартизируют работу команды, покрывают требования ТЗ, помогают быстро находить баги и регрессионно проверять.<BR>Без тест-кейсов тестирование хаотичное, баги пропускают."
            },
            {
                id: 51,
                question: "51. Жизненный цикл тест-кейса",
                answer: "Жизненный цикл тест-кейса следует STLC: от создания на основе требований до выполнения, обновления и архивирования.<BR> Этапы создания<BR> Анализ ТЗ → написание (шаги, данные, результат) → ревью коллегой → утверждение в TMS.testengineer<BR> Этапы выполнения<BR> Подготовка окружения → запуск по шагам → фиксация actual result → Passed/Failed/Blocked → баг-репорт при ошибке.qarocks<BR> Закрытие и обновление<BR> Регрессия → деактивация при устаревании → архив; обновление при изменениях в фичах.testengineer<BR>"
            },
            {
                id: 52,
                question: "52. Структура тест кейса",
                answer: "Структура тест-кейса<BR>ID, название, предусловия, шаги, ожидаемый результат, приоритет, actual result.<BR><BR>Основные поля<BR>- ID: TC_001 (для поиска)<BR>- Название: 'Успешный логин в систему'<BR>- Предусловия: пользователь зарегистрирован<BR><BR>Шаги и результат<BR>1. Ввести логин/пароль → 2. Нажать 'Войти' → Ожидаемый: профиль открылся<BR><BR>Дополнительно<BR>Приоритет (H/M/L), тестовые данные, автор, дата."
            },
            {
                id: 53,
                question: "53. Индустриальное  тестирование. Тестирование спецификации и тестирование сценариев",
                answer: "Тестирование спецификации<BR>Проверяем систему по формальным документам: ТЗ, спецификация, требования.<BR>Ориентир: что «должно быть» по документам, без привязки к реальному использованию.<BR>Задача: убедиться, что все требования реализованы и не нарушены.<BR><BR>Тестирование сценариев<BR>Проверяем по пользовательским сценариям: истории использования, бизнес‑процессы, кейсы «как живой пользователь».<BR>Ориентир: реальные шаги пользователя (например, «зарегистрироваться → положить товар в корзину → оплатить»).<BR>Задача: убедиться, что система работает корректно в типичных и критичных жизненных ситуациях."
            },
            {
                id: 54,
                question: "54. Индустриальное  тестирование. Ручная разработка тестов и генерация тестов",
                answer: "Ручная разработка тестов<BR>Тестировщик сам пишет тест-кейсы: читает ТЗ → придумывает сценарии → детализирует шаги.<BR>Плюсы: креативность, покрытие edge-кейсов.<BR>Минусы: долго, субъективно, зависит от опыта.<BR><BR>Генерация тестов<BR>Автоматическое создание тестов из моделей/спецификаций (Model-Based Testing).<BR>Инструменты строят граф состояний → генерируют тысячи сценариев.<BR>Плюсы: быстро, много тестов, объективно.<BR>Минусы: нужны модели, может генерить бесполезное."
            },
            {
                id: 55,
                question: "55. Критерии входа и критерии  выхода",
                answer: "Критерии входа<BR>Условия ДО начала тестирования: ТЗ готово, код собран, среда настроена, smoke-тесты прошли.<BR><BR>Критерии выхода<BR>Условия для ЗАВЕРШЕНИЯ: 95% тестов passed, нет P1 багов, покрытие требований 100%, отчет готов.<BR><BR>Примеры<BR>Вход: план тестирования утвержден, тестовые данные есть.<BR>Выход: высокоприоритетные тесты passed, риски оценены."
            },
            {
                id: 56,
                question: "56. Верификация и валидация",
                answer: "Верификация<BR>Проверяем: 'правильно ли сделано?' — документы, код, дизайн (статически, без запуска).<BR><BR>Валидация<BR>Проверяем: 'то ли сделано?' — запускаем продукт, смотрим на ожидания пользователя (динамически).<BR><BR>Разница<BR>Верификация: ТЗ↔код (ревью).<BR>Валидация: код↔пользователь (тесты)."
            }
        ];

        // Состояние приложения
        let openQuestions = new Set();
        
        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            const questionsContainer = document.getElementById('questions-container');
            const collapseAllButton = document.getElementById('collapse-all');
            
            // Генерируем вопросы на странице
            questionsData.forEach(q => {
                const questionElement = document.createElement('div');
                questionElement.className = 'question-item';
                questionElement.id = `question-${q.id}`;
                
                questionElement.innerHTML = `
                    <div class="question-header" data-id="${q.id}">
                        <div class="question-title">${q.question}</div>
                        <div class="toggle-icon">▼</div>
                    </div>
                    <div class="answer-content">
                        <div class="answer-text">${q.answer}</div>
                    </div>
                `;
                
                questionsContainer.appendChild(questionElement);
            });
            
            // Обработчик клика по вопросу
            document.querySelectorAll('.question-header').forEach(header => {
                header.addEventListener('click', function() {
                    const questionId = parseInt(this.getAttribute('data-id'));
                    const questionElement = document.getElementById(`question-${questionId}`);
                    
                    // Переключаем состояние вопроса
                    if (openQuestions.has(questionId)) {
                        openQuestions.delete(questionId);
                        questionElement.classList.remove('active');
                    } else {
                        openQuestions.add(questionId);
                        questionElement.classList.add('active');
                        
                        // Прокручиваем к открытому вопросу
                        questionElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
            });
            
            // Обработчик кнопки "Свернуть все"
            collapseAllButton.addEventListener('click', function() {
                document.querySelectorAll('.question-item.active').forEach(item => {
                    item.classList.remove('active');
                });
                openQuestions.clear();
            });
            
            // Добавляем обработчик для свайпов (для удобства на часах)
            let touchStartX = 0;
            let touchEndX = 0;
            
            document.addEventListener('touchstart', function(e) {
                touchStartX = e.changedTouches[0].screenX;
            });
            
            document.addEventListener('touchend', function(e) {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
            });
            
            function handleSwipe() {
                const swipeThreshold = 50;
                const diff = touchStartX - touchEndX;
                
                // Свайп влево (следующий вопрос)
                if (Math.abs(diff) > swipeThreshold) {
                    if (diff > 0) {
                        // Свайп влево - открываем следующий вопрос
                        const allQuestions = Array.from(document.querySelectorAll('.question-item'));
                        const firstClosed = allQuestions.find(q => !q.classList.contains('active'));
                        
                        if (firstClosed) {
                            const questionId = parseInt(firstClosed.id.split('-')[1]);
                            firstClosed.classList.add('active');
                            openQuestions.add(questionId);
                            firstClosed.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>